import subprocess
import healpy as hp
import numpy as np
from astropy.table import Table
from time import perf_counter
import os
import shutil
import fitsio
import scipy.stats


# JAZ needs to add this before running;
# export PATH=../flask/bin/:$PATH

RNG_BASE=400

# 
SMOOTHING = 15.0  # arcmin

# Number of sims you want
N = 50

# Arbitrary - adjust as desired
TOTAL_POINTS_FULL_SKY = 1_000_000

#  1024 is the max as that's the DES resolution
NSIDE = 512

# Get this from
MASK_FILE = 'coin-input/mask-pix.npy'
SCALING = 100.0

DES_FILE = "./coin-input/y1a1_spt_mcal_0.2_1.3_kE.fits"
DES_MASK = "./coin-input/y1a1_spt_mcal_0.2_1.3_mask.fits"

# Determined empirically to make the DES E maps std dev the same as the sims
# Not sure if there is some factor of 2 somewhere that's making this happen exactly
# or just a coincidence (actual value ~ 0.52)
DES_SCALING = SCALING * 0.5

def make_kappa_map(g1_map, g2_map, sigma_arcmin):
    """
    Make a kappa map.
    Based on Chihway's code for DES:
    https://github.com/chihway/massmapping
    """
    npix = g1_map.size
    nside = hp.npix2nside(npix)
    sigma_rad = np.radians(sigma_arcmin / 60)

    maps = [np.zeros(npix), g1_map, g2_map]
    alm = hp.map2alm(maps, pol=True)


    ell, _ = hp.Alm.getlm(lmax=3*nside-1)
    f = ((ell*(ell+1.))/((ell+2.)*(ell-1)))**0.5
    alm_E = alm[1] * f
    #alm_B = alm[2] * f

    # Remove monopole
    alm_E[ell==0] = 0.0
    #alm_B[ell==0] = 0.0

    # Remove dipole
    alm_E[ell==1] = 0.0
    #alm_B[ell==1] = 0.0

    # Make maps with smoothing
    kappa_E = hp.alm2map(alm_E, nside=nside, pol=False, sigma=sigma_rad)

    #    B_map = hp.alm2map(alm_B, nside=nside, pol=False, sigma=sigma_rad)
    
    return kappa_E

def random_points_in_triangle(p1,p2,p3,n):
    """Generate random points uniformly distributed in a triangle.

    The points can be in any number of dimensions.

    Params
    ------
    p1: 1D array
        Vector pointing to the first vertex
    p2: 1D array
        Vector pointing to the second vertex
    p3: 1D array
        Vector pointing to the third vertex
    n: int
        Number of points to generate

    Returns
    -------
    p: array
        n * ndim array of points in the triangle

    """
    # Find the edge vector
    v1 = p2-p1
    v2 = p3-p1

    # Generate 2n random uniform values
    # as a1 and a2
    a = np.random.uniform(0.,1.,2*n)
    a1 = a[:n]
    a2 = a[-n:]

    # Find any points that flipped over to being outside
    # the triangle and flip them back in
    w = np.where(a1+a2>1)
    a1[w] = 1 - a1[w]
    a2[w] = 1 - a2[w]

    # Generate p_{ij} = p1_{j} + a1_{i}*v1_{j} + a2_{i}*v2_{j}
    # which should be uniformly distributed in the quadrilateral
    p = p1[np.newaxis,:] + np.einsum('i,j->ij',a1,v1) + np.einsum('i,j->ij',a2,v2)
    
    return p

def prepare_quadrilateral_sampling(vertices):
    """Prepare to generate random points uniformly distributed in a quadrilateral.

    The points can be in any number of dimensions.  If two of them
    co-incide so you are actually specifying a triangle it will still work.

    As long as you specify the vertices consistently either clockwise or
    anti-clockwise is okay.

    Params
    ------
    p1: 1D array
        Vector pointing to the first vertex
    p2: 1D array
        Vector pointing to the second vertex
    p3: 1D array
        Vector pointing to the third vertex
    p4: 1D array
        Vector pointing to the fourth vertex
    n: int
        Number of points to generate

    Returns
    -------
    p: array
        n * ndim array of points in the quadrilateral

    """

    p1, p2, p3, p4 = vertices.T
    # Find the edge vectors
    v1 = p2-p1
    v2 = p3-p2
    v3 = p4-p3
    v4 = p1-p4
    
    # Find the area of the two triangles making up the quadrilateral,
    # And therefore the expected fraction of the points in each half.
    A1 = 0.5*np.linalg.norm(np.cross(v1,v2))
    A2 = 0.5*np.linalg.norm(np.cross(v3,v4))
    f1 = abs(A1)/abs(A1+A2)

    return p1,p2,p3,p4,f1

def sample_quadrilateral(n, info):
    p1,p2,p3,p4,f1 = info
    # We choose the actual number of points according to a binomial distribution
    n1 = scipy.stats.binom.rvs(n,f1)
    n2 = n - n1

    # Now generate the points in each half-triangle
    x1 = random_points_in_triangle(p1,p2,p3,n1)
    x2 = random_points_in_triangle(p1,p3,p4,n2)

    # Group the points and return
    return np.vstack((x1,x2))







def make_maps():
    # Noisy ellipticity maps made by flask
    e1, e2=hp.read_map("./coin/ellip-map-f1z1.fits", [1,2])

    # Noisy kappa map, made by running kappa mapping on the ellipticity maps
    kappa_noisy = make_kappa_map(e1, e2, SMOOTHING)

    # Noise-free kappa map, generated by flask
    kappa_noise_free = hp.read_map("./coin/kappa-gamma-f2z1.fits", [0])

    # Return both
    return kappa_noisy, kappa_noise_free


def run_flask(i, nside):
    os.makedirs("coin", exist_ok=True)
    subprocess.check_call(["flask", "coin.config", 
        "RNDSEED:", str(RNG_BASE + i), 
        "NSIDE:", str(nside),
        "SHEAR_LMAX", str(nside-1),
        "LRANGE", "1", str(nside-1),

        ])

def load_mask(nside):
    nside_in, w = np.load(MASK_FILE)
    npix_in = hp.nside2npix(nside_in)
    m = np.zeros(npix_in)
    m[w] = 1
    m = hp.ud_grade(m, nside_out=nside, pess=False)
    return m


def simulate_points(m_in, n, info, scaling=SCALING):
    m = (1 + scaling * m_in).clip(0, np.inf)
    m[m_in==0] = 0
    npix = m.size
    pix_prob = m / m.sum()
    #  Choose random pixels
    pix = np.random.choice(npix, size=n, replace=True, p=pix_prob)
    counts = np.zeros(npix, dtype=int)

    for p in pix:
        counts[p] += 1
  
    Ra = []
    Dec = []

    for i in range(npix):
        if counts[i]==0:
            continue

        P = sample_quadrilateral(counts[i], info[i])
        ra, dec = hp.vec2ang(P, lonlat=True)
        Ra.append(ra)
        Dec.append(dec)

    Ra = np.concatenate(Ra)
    Dec = np.concatenate(Dec)

    return Ra, Dec


def prepare_sampling(nside):
    os.makedirs("cache", exist_ok=True)
    filename = f'cache/sampling-{nside}.npy'
    if os.path.exists(filename):
        sample_info = np.load(filename)
        return sample_info
    npix = hp.nside2npix(nside)
    p = np.arange(npix, dtype=int)
    vertices = hp.boundaries(nside, p)
    sample_info = []
    for v in vertices:
        sample_info.append(prepare_quadrilateral_sampling(v))
    np.save(filename, sample_info)
    return sample_info


def save_results(i, p, full, noisy):
    os.makedirs("coin-points", exist_ok=True)
    f = 'full' if full else 'masked'
    n ='noisy' if noisy else 'noisefree'
    filename = f'coin-points/{i}-{f}-{n}.fits'
    cat = Table(p, names=['ra', 'dec'])
    cat.write(filename, overwrite=True)

class Timer:
    def __init__(self):
        self.t0 = perf_counter()
        self.t1 = self.t0
    def mark(self, msg):
        t = perf_counter()
        dt0 = t - self.t0
        dt1 = t - self.t1
        print(f"{msg} since last mark: {dt1:.2f}  overall: {dt0:.2f}")
        self.t1 = t

def main():
    T = Timer()
    nside = NSIDE
    mask = load_mask(nside)
    T.mark("load_mask")
    sample_info = prepare_sampling(nside)
    T.mark("prep_sampling")
    mask_fraction = mask.sum() / mask.size

    nfull = TOTAL_POINTS_FULL_SKY
    nmasked = int(nfull * mask_fraction)

    print(f"N for full sky: {nfull}, for masked sky: {nmasked}")

    for i in range(N):
        print(f"Running iteration {i}")
        run_flask(i, nside)
        T.mark("run_flask")

        # Load and generate noisy and noise-free maps
        kappa_noisy, kappa_noise_free = make_maps()
        T.mark("make_maps")

        # Generate masked versions of the maps maps
        masked_noisy = kappa_noisy * mask
        masked_noise_free = kappa_noise_free * mask

        # Simulates points from the map as an input to the
        # algorithm
        full_noisy_points = simulate_points(kappa_noisy, nfull, sample_info)
        T.mark("simulated_full_noisy")
        full_noise_free_points = simulate_points(kappa_noise_free, nfull, sample_info)
        T.mark("simulated_full_noisfree")
        masked_noisy_points = simulate_points(masked_noisy, nmasked, sample_info)
        T.mark("simulated_masked_noisy")
        masked_noise_free_points = simulate_points(masked_noise_free, nmasked, sample_info)
        T.mark("simulated_masked_noisfree")

        save_results(i, full_noisy_points, full=True, noisy=True)
        save_results(i, full_noise_free_points, full=True, noisy=False)
        save_results(i, masked_noisy_points, full=False, noisy=True)
        save_results(i, masked_noise_free_points, full=False, noisy=False)
        T.mark("saved_results")

        shutil.copy("coin/kappa-gamma-f2z1.fits", f"coin-points/{i}-truth-maps.fits")

def des_main():
    T = Timer()

    sigma_rad = np.radians(SMOOTHING / 60)

    E = fitsio.read(DES_FILE)['kE']
    E = hp.smoothing(E, sigma=sigma_rad)
    E = hp.ud_grade(E, nside_out=NSIDE)

    T.mark("prepared_des_map")

    mask = fitsio.read(DES_MASK)['mask']
    mask = hp.ud_grade(mask, nside_out=NSIDE)
    mask_fraction = mask.sum() / mask.size
    T.mark("prepared_des_mask")

    E *= mask

    nfull = TOTAL_POINTS_FULL_SKY
    nmasked = int(nfull * mask_fraction)

    sample_info = prepare_sampling(NSIDE)
    T.mark("prepared_sampling_info")

    des_points = simulate_points(E, nfull, sample_info, scaling=DES_SCALING)
    T.mark("simulated_des_points")

    save_results('des', des_points, full=False, noisy=True)


if __name__ == '__main__':
    des_main()
    main()
